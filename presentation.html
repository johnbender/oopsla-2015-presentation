<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Declarative Fence Insertion</title>
<meta name="author" content="(John Bender, Jens Palsberg - UCLA  (export-snippet (:back-end html :value  <br/>  :begin 35 :end 52 :post-blank 1 :parent #0)) Mohsen Lesani - MIT)"/>

<link rel="stylesheet" href="assets/reveal/css/reveal.css"/>
<link rel="stylesheet" href="assets/reveal/css/theme/white.css" id="theme"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'assets/reveal/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" type="text/css" href="assets/style.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1>Declarative Fence Insertion</h1>
<h2>John Bender, Jens Palsberg - UCLA  <br/>  Mohsen Lesani - MIT</h2>
<h2><a href="mailto:"></a></h2>
<h2></h2>
</section>
</section>
</section>
<section>
<section id="slide-sec-0-1">
<h3 id="sec-0-1"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<ul class="org-ul">
<li>Our work focuses on performance critical concurrent algorithms
</li>

<li>To illustrate the problem we have an example of one such algorithm
from the art of multiproc programming
</li>

<li>lock intended to guarantee mutual exclusion for two threads
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-2">
<h3 id="sec-0-2"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];
                                       &#9650;
  <span class="org-keyword">public</span> <span class="org-type">void</span> lock() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
There are two flags, one for each thread
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-3">
<h3 id="sec-0-3"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
&#9654;   <span class="org-type">int</span> i = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>


<aside class="notes">
<p>
Each thread gets it's own id &#x2026;
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-4">
<h3 id="sec-0-4"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
&#9654;   <span class="org-type">int</span> j = 1-i;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
&#x2026; then flips the bit to get the other id
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-5">
<h3 id="sec-0-5"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
&#9654;   flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
each thread marks it's own flag as true
</p>

<p>
signals intent to enter the critical section
threads
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-6">
<h3 id="sec-0-6"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
    flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
each thread then checks the <b>other</b> thread's flag
</p>

<p>
if the other thread's flag is set, it waits
</p>

<p>
otherwise it the lock method returns, meaning it's ok to proceed
into some protected critical section of the code
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-7">
<h3 id="sec-0-7"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
&#9654;   flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
These two operations are critical:
</p>

<p>
The proof of mutual exclusion in the book requires that these two
lines execute in program order
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-8">
<h3 id="sec-0-8">good execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[0] = true</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">spin</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<aside class="notes">
<ul class="org-ul">
<li>assuming everything behaves as expected
</li>
<li>example execution of two operations
</li>
<li>key: no way to mix up the instructions s.t. both can acquire/proceed
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-9">
<h3 id="sec-0-9">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><span class="hlght"> <code>flag[0] = true</code> </span></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">spin</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<aside class="notes">
<ul class="org-ul">
<li>x86, ARM, and Power either store maybe be "reordered"
</li>
<li>reasons: store buffering, literal OOE
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-10">
<h3 id="sec-0-10">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : false</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">enter</td>
</tr>

<tr>
<td class="left"><span class="hlght">  <code>flag[0] = true</code> </span></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<aside class="notes">
<ul class="org-ul">
<li>if that happens we might see an execution like this
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-11">
<h3 id="sec-0-11">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><span class="hlght"> <code>flag[1] : false</code> </span></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><span class="hlght"> <code>flag[0] : false</code> </span></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">enter</td>
</tr>

<tr>
<td class="left"><code>flag[0] = true</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<aside class="notes">
<ul class="org-ul">
<li>now possible for both flag checks to see <code>false</code>
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-12">
<h3 id="sec-0-12">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : false</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><span class="hlght">  enter </span></td>
</tr>

<tr>
<td class="left"><code>flag[0] = true</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><span class="hlght">  enter </span></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<aside class="notes">
<ul class="org-ul">
<li>then possible for both threads to proceed into the protected code
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-13">
<h3 id="sec-0-13">traditional solutions</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">solutions</th>
<th scope="col" class="left">lost semantics</th>
<th scope="col" class="left">error prone</th>
<th scope="col" class="left">overkill</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">sequential consistency</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><code>volatile</code> modifier</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left">memory fences</td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must
all be declared volatile to work properly.
</p>
</blockquote>

<aside class="notes">
<p>
traditional solutions:
</p>

<ul class="org-ul">
<li>sc
</li>
<li>volatile (java)
</li>
<li>memory fences (c/c++)
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-14">
<h3 id="sec-0-14">traditional solutions</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">solutions</th>
<th scope="col" class="left">lost semantics</th>
<th scope="col" class="left">error prone</th>
<th scope="col" class="left">overkill</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><span class="hlght"> sequential consistency </span></td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><code>volatile</code> modifier</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left">memory fences</td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must
all be declared volatile to work properly.
</p>
</blockquote>

<aside class="notes">
<ul class="org-ul">
<li>many ops can safely reorder for performance
</li>
<li>the algorithm will continue to work fine
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-15">
<h3 id="sec-0-15">traditional solutions</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">solutions</th>
<th scope="col" class="left">lost semantics</th>
<th scope="col" class="left">error prone</th>
<th scope="col" class="left">overkill</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">sequential consistency</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><span class="hlght"> <code>volatile</code> modifier </span></td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left">memory fences</td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must
all be declared volatile to work properly.
</p>
</blockquote>

<aside class="notes">
<ul class="org-ul">
<li>the reason for marking variable volatile is unclear for newcomers
</li>
<li>every operation on volatile variables is affected, unnecessary
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-16">
<h3 id="sec-0-16">traditional solutions</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">solutions</th>
<th scope="col" class="left">lost semantics</th>
<th scope="col" class="left">error prone</th>
<th scope="col" class="left">overkill</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">sequential consistency</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><code>volatile</code> modifier</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><span class="hlght"> memory fences </span></td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must
all be declared volatile to work properly.
</p>
</blockquote>

<aside class="notes">
<ul class="org-ul">
<li>relates many instructions obscuring the reason for placement
</li>
<li>you really need to know the docs to get these right
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-17">
<h3 id="sec-0-17">traditional solutions</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">solutions</th>
<th scope="col" class="left">lost semantics</th>
<th scope="col" class="left">error prone</th>
<th scope="col" class="left">overkill</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><span class="hlght"> sequential consistency </span></td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><span class="hlght"> <code>volatile</code> modifier </span></td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><span class="hlght"> memory fences </span></td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must
all be declared volatile to work properly.
</p>
</blockquote>

<aside class="notes">
<ul class="org-ul">
<li>implementation details of a higher level concept
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-18">
<h3 id="sec-0-18">execution order</h3>
<blockquote nil>
<p>
The requirement that two instructions appear to execute in program order.
</p>
</blockquote>

<aside class="notes">
<ul class="org-ul">
<li>simple but useful
</li>
<li>higher level concept is the execution order
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-19">
<h3 id="sec-0-19">algorithms = code + orders</h3>
<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
&#9654;   flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>
<p>

   <span class="plus">+</span>
   <div class="order">

\(\{ st(\mathtt{flag[i]}) \rightarrow ld(\mathtt{flag[j]}) \}\)

   </div>

</p>

<aside class="notes">
<ul class="org-ul">
<li>LockOne not finished without orders!
</li>
<li>requires a side note in the book about <code>volatile</code>
</li>
<li>o/w it doesn't work properly
</li>
<li>"so the algorithim is in fact code plus a set of orders"
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1">
<h2 id="sec-1">Enforcing Orders</h2>
<aside class="notes">
<ul class="org-ul">
<li>how do we help implementers use orders?
</li>
<li>fence insertion!
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-1">
<h3 id="sec-1-1">previous approaches</h3>
<ul>
<li>Insert fences to&#x2026;
<ul>
<li>enforce sequential consistency</li>
<li>enforce a specification</li>

</ul></li>
<li>Whole program, O(2<sup>n</sup>)</li>

</ul>

<aside class="notes">
<p>
SC: overkill in many cases
</p>

<p>
Spec:
</p>

<p>
Can be thought of as "finding the orders" necessary to ensure properties
</p>

<p>
some properties don't work well as specification
</p>

<p>
Orders exist as fragments of proofs which can't easily
be translated into specifications, eg stm correctness
</p>

<p>
Both: Whole program, don't scale well
</p>

<p>
SC: Don't Sit On the Fence, CAV'14, alglave et al
</p>

<p>
Spec: Automatic Inference of Memory Fences, FMCAD '10, Kuperstein et al
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-1-2">
<h3 id="sec-1-2">our approach</h3>
<ul>
<li>Orders as part of the algorithm</li>
<li>Insert fences to enforce orders</li>
<li>Per-procedure
<ul>
<li>still O(2<sup>n</sup>) but inputs are small</li>

</ul></li>

</ul>

<aside class="notes">
<p>
This places our analysis at the procedure level.
</p>

<p>
A Calculus for Relaxed Memory Models, PLDI 2015, Crary et al
</p>

<p>
they built the semantics, we built the tool
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2">
<h2 id="sec-2">Fence Insertion Subtleties</h2>
<aside class="notes">
<p>
We have an idea of what we think algorithms should look like,
what's standing in our way?
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2-1">
<h3 id="sec-2-1">many platforms</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = get_thread_id();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
  flag[i] = <span class="org-constant">true</span>;

&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"mfence"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">x86</span>
&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb"</span>);    <span class="org-comment-delimiter">// </span><span class="org-comment">ARMv7</span>

  <span class="org-keyword">while</span> (flag[j]) {}
}
</pre>
</div>

<aside class="notes">
<p>
assuming we're programming at the level of C/C++ we need to use an
architecture appropriate fence instruction to ensure the two orders
defined in the proof
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-2">
<h3 id="sec-2-2">fence selection</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = get_thread_id();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;
  flag[i] = <span class="org-constant">true</span>;

&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb"</span>);
&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb st"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">may be faster</span>

  <span class="org-keyword">while</span> (flag[j]) {}
}
</pre>
</div>

<aside class="notes">
<p>
different paired instructions may require different fences,
optimizing for performance
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-3">
<h3 id="sec-2-3">existing fence(-likes)</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = get_thread_id();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = 1-i;

  <span class="org-comment-delimiter">// </span><span class="org-comment">x86:   cmpxchg</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">ARMv7: ldrex/strex</span>
&#9654; CAS(flag[i], <span class="org-constant">false</span>, <span class="org-constant">true</span>);

  <span class="org-keyword">while</span> (flag[j]) {}
}
</pre>
</div>

<aside class="notes">
<p>
there are other instructions like `cmpxhg` which have fence like
semantics that we should account for (by avoiding adding more fences).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-4">
<h3 id="sec-2-4">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
&#9654;   WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<ul class="org-ul">
<li>this is code from the tl2 transactional memory algorithm
</li>
<li>avoiding details
</li>
<li>there's a store to memory in the writebackforward
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-5">
<h3 id="sec-2-5">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
    WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
&#9654; DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<ul class="org-ul">
<li>must happen before the store in droplocks for the algo to work
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2-6">
<h3 id="sec-2-6">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
    WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
&#9654; MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<ul class="org-ul">
<li>the authors of the code add these fence macros
</li>
<li>provide a way to define platform appropriate solution to prevent
stores from swapping
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2-7">
<h3 id="sec-2-7">code transformations</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
&#9654; <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
&#9654;   <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
&#9654;   WriteBackForward(wr);
&#9654; }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<ul class="org-ul">
<li>if <code>TL2_EAGER</code> is defined will remove writebackforward
</li>
<li>so the macro and fence becomes unnecessary
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-8">
<h3 id="sec-2-8">faux order</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
&#9654;   WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
&#9654; DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<ul class="org-ul">
<li>more generally the implementers really wanted to define an order here
</li>
<li>by using a fence macro anyone coming to the code has to have the algorithm
spec in hand to determine why that fence was placed
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-3">
<h2 id="sec-3">Algorithm</h2>
<div class="outline-text-2" id="text-3">
</div></section>
</section>
<section>
<section id="slide-sec-3-1">
<h3 id="sec-3-1">algorithm</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
      &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph.png" alt="full-graph.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>our algorithm insert
</li>
<li>left code, right inputs except for the architecture
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-2">
<h3 id="sec-3-2">control flow graph</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
            &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-fst-input.png" alt="full-graph-fst-input.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>control flow graph for some simple procedure
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-3-3">
<h3 id="sec-3-3">architecture spec</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
               &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>


<div class="figure">
<p><img src="assets/images/full-graph.png" alt="full-graph.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>an architecture specification not pictured here
</li>
<li>it tells us what the architecture WONT reorder
</li>
<li>we'll assume ARM for the sake of the example
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-3-4">
<h3 id="sec-3-4">orders</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
                   &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-third-input.png" alt="full-graph-third-input.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>set of orders that need to be enforced
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-3-5">
<h3 id="sec-3-5">order elimination</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

&#9654; <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-elim.png" alt="full-graph-elim.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>first step is order elimination
</li>
<li>we want to avoid inserting fences where they are unnecessary
</li>
<li>on arm (and every other architecture) a load won't move past a store to the same address
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-6">
<h3 id="sec-3-6">order elimination</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

&#9654; <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-elim-after.png" alt="full-graph-elim-after.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>so we can safely discard that order
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-7">
<h3 id="sec-3-7">fence position</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

&#9654; <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut.png" alt="full-graph-cut.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>the next step is finding good places for fences that will enforce the orders
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-8">
<h3 id="sec-3-8">fence position</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

&#9654; <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut-highlight.png" alt="full-graph-cut-highlight.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>we consider all the orders
</li>
<li>use multicut to find an optimal set of edges to separate the sources from the sinks
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-9">
<h3 id="sec-3-9">fence position</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

&#9654; <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut-highlight-2.png" alt="full-graph-cut-highlight-2.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>so our cut set K is just the one edge between the two stores
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-10">
<h3 id="sec-3-10">fence placement</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

&#9654; <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-refine.png" alt="full-graph-refine.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ul class="org-ul">
<li>finally we use the cut set to place fences in the control flow graph
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-11">
<h3 id="sec-3-11">fence placement</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

&#9654; <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-refine-apply.png" alt="full-graph-refine-apply.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-3-12">
<h3 id="sec-3-12">main theorem</h3>
<p>
\(\mathsf{Insert}(G, A, O), A \vDash O\)
</p>

<aside class="notes">
<p>
intuitively, Given a graph, architecture and orders <code>insert</code>
will produce a graph that, assuming the same architecture
will enforce the orders
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-4">
<h2 id="sec-4">Results/Parry</h2>
<aside class="notes">
<ul class="org-ul">
<li>we built a tool called Parry
</li>
<li>see how well this idea can be implemented
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-4-1">
<h3 id="sec-4-1">benchmark: classic algorithms</h3>
<ul>
<li>from Algave et al '14</li>
<li>x86 and ARMv7</li>
<li>4 lock free algorithms</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-4-2">
<h3 id="sec-4-2">benchmark: STM algorithms</h3>
<ul>
<li>TL2/TL2 Eager</li>
<li>Rochester ByteEager (TLRW)</li>
<li>x86 and ARMv7</li>

</ul>

<aside class="notes">
<ul class="org-ul">
<li>TL2/TL2 Eager
<ul class="org-ul">
<li>included with STAMP Benchmarks
</li>
</ul>
</li>
<li>RSTM ByteEager
<ul class="org-ul">
<li>part of Rochester STM Algorithm Suite
</li>
</ul>
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-4-3">
<h3 id="sec-4-3">benchmark: STM algorithms</h3>
<ul>
<li><b>baseline</b>: original fences</li>
<li><b>Parry</b>: fences placed by Parry</li>

</ul>

<aside class="notes">
<ul class="org-ul">
<li>baseline is fences already placed in algorithms
</li>
<li>ours is fences placed by parry using orders from algorithm definitions
</li>

<li>TL2 is the largest in terms of procedure size
</li>
<li>TxCommit method has nearly 400 nodes
</li>
<li>Just under 30s to run for 3 procedures in TL2
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-4-4">
<h3 id="sec-4-4">tl2 - ARMv7</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">baseline</td>
<td class="left">Parry</td>
</tr>

<tr>
<td class="left"><b><code>TxStore</code></b></td>
<td class="left"><span class="hlght"> 1920: <code>dmb</code> </span></td>
<td class="left"><span class="hlght"> 1886: <code>dmb</code> </span></td>
</tr>
</tbody>
</table>


<aside class="notes">
<p>
TxStore: we placed our fence "further up" the control flow graph,
this is dues to the way the multicut algorithm handles a sequence
of similarly weighted edges, choosing the first
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-4-5">
<h3 id="sec-4-5">tl2 eager - ARMv7</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">baseline</td>
<td class="left">Parry</td>
</tr>

<tr>
<td class="left"><b><code>TxCommit</code></b></td>
<td class="left"><span class="hlght"> 1669: <code>dmb st</code> </span></td>
<td class="left"><span class="hlght">  — </span></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Not that due to the ifdefs we saw in the example earlier we are
able to eliminate the stst fence at line 1669 on arm
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-4-6">
<h3 id="sec-4-6">rstm - ARMv7</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">baseline</td>
<td class="left">Parry</td>
</tr>

<tr>
<td class="left"><b><code>read_rw</code></b></td>
<td class="left"><span class="hlght"> 163: <code>ldrex/strex</code> </span></td>
<td class="left"><span class="hlght"> 163: <code>dmb st</code> </span></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
in the <code>read_rw</code> method of the RSTM ByteEager algorithm they use a
compare and swap to enforce a store/store order
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-4-7">
<h3 id="sec-4-7">tl2 performance</h3>

<div class="figure">
<p><img src="./assets/images/stamp-arm-tl2.png" alt="stamp-arm-tl2.png" />
</p>
</div>

<aside class="notes">
<ul class="org-ul">
<li>STAMP results for TL2 on ARM
</li>
<li>Gray bars are Parry
</li>
<li>matched hand placed fences
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-4-8">
<h3 id="sec-4-8">rstm performance</h3>

<div class="figure">
<p><img src="./assets/images/stamp-arm-rstm.png" alt="stamp-arm-rstm.png" />
</p>
</div>

<aside class="notes">
<ul class="org-ul">
<li>STAMP results for RSTM/byteeager on ARM
</li>
<li>verified that slower due to the pairing of a store/dmb st fence
</li>
<li>suggests ldrex/strex can be faster in some circumstances
</li>
</ul>

</aside>
</section>
</section>
<section>
<section id="slide-sec-5">
<h2 id="sec-5">algorithms = code + orders</h2>
<ul>
<li>Describe the algorithm behavior</li>
<li>Let the compiler enforce the orders</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-6">
<h2 id="sec-6">Thanks!</h2>
</section>
</section>
</div>
</div>

<script src="assets/reveal/lib/js/head.min.js"></script>
<script src="assets/reveal/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: false,
progress: true,
history: true,
center: true,
slideNumber: true,
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'assets/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'assets/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'assets/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'assets/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: 'assets/reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'assets/reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
]
});
</script>
</body>
</html>
