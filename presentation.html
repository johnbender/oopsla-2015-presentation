<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Declarative Fence Insertion</title>
<meta name="author" content="(John Bender, Jens Palsberg - UCLA  (export-snippet (:back-end html :value  <br/>  :begin 35 :end 52 :post-blank 1 :parent #0)) Mohsen Lesani - MIT)"/>

<link rel="stylesheet" href="assets/reveal/css/reveal.css"/>
<link rel="stylesheet" href="assets/reveal/css/theme/white.css" id="theme"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'assets/reveal/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" type="text/css" href="assets/style.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1>Declarative Fence Insertion</h1>
<h2>John Bender, Jens Palsberg - UCLA  <br/>  Mohsen Lesani - MIT</h2>
<h2><a href="mailto:"></a></h2>
<h2></h2>
</section>
</section>
</section>
<section>
<section id="slide-sec-0-1">
<h3 id="sec-0-1"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-2">
<h3 id="sec-0-2"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];
                                       &#9650;
  <span class="org-keyword">public</span> <span class="org-type">void</span> lock() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-3">
<h3 id="sec-0-3"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
&#9654;   <span class="org-type">int</span> i = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>


<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-4">
<h3 id="sec-0-4"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
&#9654;   <span class="org-type">int</span> j = i-1;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-5">
<h3 id="sec-0-5"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
&#9654;   flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-6">
<h3 id="sec-0-6"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
    flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-7">
<h3 id="sec-0-7"><code>LockOne</code> mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<p>
Maurice Herlihy &amp; Nir Shavit, 2012
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
&#9654;   flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
These two lines are critical:
</p>

<ul class="org-ul">
<li>the first records an intent to enter a critical section guarded by the lock
at the flag index corresponding to the thread id
</li>
<li>the second checks the other thread's flag and spins until it's false (unlocked)
</li>
</ul>

<p>
The proof of mutual exclusion in the book requires that these two
lines execute in program order
</p>

<p>
More specifically, their interactions with memory must take effect
in program order
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-8">
<h3 id="sec-0-8">good execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[0] = true</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">spin</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

</section>
</section>
<section>
<section id="slide-sec-0-9">
<h3 id="sec-0-9">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><span class="hlght"> <code>flag[0] = true</code> </span></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">spin</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

</section>
</section>
<section>
<section id="slide-sec-0-10">
<h3 id="sec-0-10">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : false</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">enter</td>
</tr>

<tr>
<td class="left"><span class="hlght">  <code>flag[0] = true</code> </span></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">enter</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

</section>
</section>
<section>
<section id="slide-sec-0-11">
<h3 id="sec-0-11">bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : false</code></td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><span class="hlght">  enter </span></td>
</tr>

<tr>
<td class="left"><code>flag[0] = true</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><span class="hlght">  enter </span></td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>
Note that this is possible under extremely common memory models
like Java, x86, ARM, and Power
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-12">
<h3 id="sec-0-12">traditional solutions</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">solutions</th>
<th scope="col" class="left">lost semantics</th>
<th scope="col" class="left">error prone</th>
<th scope="col" class="left">overkill</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">sequential consistency</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left"><code>volatile</code> modifier</td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">✓</td>
</tr>

<tr>
<td class="left">memory fences</td>
<td class="left">✓</td>
<td class="left">✓</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must all
be declared <code>volatile</code> to work properly.
</p>
</blockquote>

<aside class="notes">
<p>
traditional solutions
</p>

<p>
sequential consistency:
sem: The actual required behavior for the algorithm is subsumed by sequential consistency
over: Many instructions can reorder and the algorithm can work just fine
</p>

<p>
volatile:
sem/error: establishes happens-before between many reads and writes
   when often there are only few important ones
overkill: may need just one or two
</p>

<p>
memory fences:
sem/error:
  in C/C++ memory fences appearing in code relate many instructions before
  and after, again loosing information.
</p>

<p>
Also easy to mess up placement/required instruction
</p>

<p>
!!All of these are implementation details of a higher level concept
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-13">
<h3 id="sec-0-13">execution order:</h3>
<blockquote nil>
<p>
The requirement that two instructions appear to execute in program order.
</p>
</blockquote>

</section>
</section>
<section>
<section id="slide-sec-0-14">
<h3 id="sec-0-14">algorithms = code + orders</h3>
<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>
<p>

   <span class="plus">+</span>
   <div class="order">

\(\{ st(\mathtt{flag[i]}) \rightarrow ld(\mathtt{flag[j]}) \}\)

   </div>

</p>

</section>
</section>
<section>
<section id="slide-sec-0-15">
<h3 id="sec-0-15">Enforcing Orders</h3>
<p>
How do we help implementers use orders?
</p>

<p>
Fence insertion!
</p>
</section>
</section>
<section>
<section id="slide-sec-0-16">
<h3 id="sec-0-16">previous approaches</h3>
<ul>
<li>Insert fences to&#x2026;
<ul>
<li>enforce sequential consistency</li>
<li>enforce a specification</li>

</ul></li>
<li>Whole program, O(2<sup>n</sup>)</li>

</ul>

<aside class="notes">
<p>
SC: Don't Sit On the Fence, CAV'14
</p>

<p>
Spec: Automatic Inference of Memory Fences, FMCAD '10
</p>

<p>
Whole program, don't scale well
</p>

<p>
Orders exist as fragments of proofs which can't easily
be translated into specifications
</p>

<p>
e.g. opacity correctness condition for the STM algorithms we consider in our results
</p>

<p>
Can be thought of as "finding the orders" necessary to ensure properties
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-0-17">
<h3 id="sec-0-17">our approach</h3>
<ul>
<li>Orders as part of the algorithm</li>
<li>Insert fences to enforce orders</li>
<li>Per-procedure
<ul>
<li>still O(2<sup>n</sup>) but inputs are small</li>

</ul></li>

</ul>

<aside class="notes">
<p>
This places our analysis at the procedure level.
</p>

<p>
CMU paper: PLDI 2015 has semantics, we've built the tool
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1">
<h2 id="sec-1">Fence Insertion Subtleties</h2>
<aside class="notes">
<p>
We have an idea of what we think algorithms should look like,
what's standing in our way?
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-1-1">
<h3 id="sec-1-1">many platforms</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = get_thread_id();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
  flag[i] = <span class="org-constant">true</span>;

&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"mfence"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">x86</span>
&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb"</span>);    <span class="org-comment-delimiter">// </span><span class="org-comment">ARMv7</span>

  <span class="org-keyword">while</span> (flag[j]) {}
}
</pre>
</div>

<aside class="notes">
<p>
assuming we're programming at the level of C/C++ we need to use an
architecture appropriate fence instruction to ensure the two orders
defined in the proof
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-2">
<h3 id="sec-1-2">fence selection</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = get_thread_id();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
  flag[i] = <span class="org-constant">true</span>;

&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb"</span>);
&#9654; <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb st"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">may be faster</span>

  <span class="org-keyword">while</span> (flag[j]) {}
}
</pre>
</div>

<aside class="notes">
<p>
different paired instructions may require different fences,
optimizing for performance
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-3">
<h3 id="sec-1-3">existing fence(-likes)</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = get_thread_id();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;

  <span class="org-comment-delimiter">// </span><span class="org-comment">x86:   cmpxchg</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">ARMv7: ldrex/strex</span>
&#9654; CAS(flag[i], <span class="org-constant">false</span>, <span class="org-constant">true</span>);

  <span class="org-keyword">while</span> (flag[j]) {}
}
</pre>
</div>

<aside class="notes">
<p>
there are other instructions like `cmpxhg` which have fence like
semantics that we should account for (by avoiding adding more fences).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-4">
<h3 id="sec-1-4">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
&#9654;   WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<p>
commit procedure for the tl2 software transactional memory algorithm
writebackforward is where the actual writes to memory take place
droplocks releases locks for the memory addresses for other commit calls to write
macros provided for implementors to define arch appropriate fences
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-5">
<h3 id="sec-1-5">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
    WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
&#9654; DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<p>
commit procedure for the tl2 software transactional memory algorithm
writebackforward is where the actual writes to memory take place
droplocks releases locks for the memory addresses for other commit calls to write
macros provided for implementors to define arch appropriate fences
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-1-6">
<h3 id="sec-1-6">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
    WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
&#9654; MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<p>
commit procedure for the tl2 software transactional memory algorithm
writebackforward is where the actual writes to memory take place
droplocks releases locks for the memory addresses for other commit calls to write
macros provided for implementors to define arch appropriate fences
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-1-7">
<h3 id="sec-1-7">code transformations</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
&#9654; <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
&#9654;   <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
&#9654;   WriteBackForward(wr);
&#9654; }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<p>
bad to use a fence if <code>TL2_EAGER</code> is defined (will remove writebackforward)
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-8">
<h3 id="sec-1-8">unnecessary fences</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
    WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
&#9654; MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<p>
bad to use a fence for <code>MEMBARSTST</code> on x86
</p>

<p>
implementers really wanted orders here
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-1-9">
<h3 id="sec-1-9">faux order</h3>
<div class="org-src-container">

<pre  class="src src-c">  ...

<span class="org-preprocessor">  # if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
  <span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
    WriteBackForward(wr);
  }
<span class="org-preprocessor">  # endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
&#9654; MEMBARSTST();

  <span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
  DropLocks(Self, wv);

  ...
</pre>
</div>

<aside class="notes">
<p>
implementers really wanted orders here
</p>

<p>
defining the macro based on the platform solves the cross platform issue
</p>

<p>
coming to the code later, it's still not clear what the purpose was unless
one knows the algorithm
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2">
<h2 id="sec-2">Algorithm</h2>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph.png" alt="full-graph.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ol class="org-ol">
<li>We eliminate orders which are enforced on the target
architecture, e.g. a store -&gt; store order on x86 is enforced
by the architecture. <b>optimization</b>
</li>

<li>We find a multicut for the remaining orders and the control flow graph G
</li>

<li>We use the cut to insert fences on the cut set edges
</li>
</ol>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-1">
<h3 id="sec-2-1">control flow graph</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
            &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-fst-input.png" alt="full-graph-fst-input.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ol class="org-ol">
<li>We eliminate orders which are enforced on the target
architecture, e.g. a store -&gt; store order on x86 is enforced
by the architecture. <b>optimization</b>
</li>

<li>We find a multicut for the remaining orders and the control flow graph G
</li>

<li>We use the cut to insert fences on the cut set edges
</li>
</ol>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2-2">
<h3 id="sec-2-2">architecture spec</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
               &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph.png" alt="full-graph.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ol class="org-ol">
<li>We eliminate orders which are enforced on the target
architecture, e.g. a store -&gt; store order on x86 is enforced
by the architecture. <b>optimization</b>
</li>

<li>We find a multicut for the remaining orders and the control flow graph G
</li>

<li>We use the cut to insert fences on the cut set edges
</li>
</ol>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2-3">
<h3 id="sec-2-3">orders</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):
                   &#9650;
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-third-input.png" alt="full-graph-third-input.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ol class="org-ol">
<li>We eliminate orders which are enforced on the target
architecture, e.g. a store -&gt; store order on x86 is enforced
by the architecture. <b>optimization</b>
</li>

<li>We find a multicut for the remaining orders and the control flow graph G
</li>

<li>We use the cut to insert fences on the cut set edges
</li>
</ol>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2-4">
<h3 id="sec-2-4">order elimination</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

&#9654; <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-elim.png" alt="full-graph-elim.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-5">
<h3 id="sec-2-5">order elimination</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

&#9654; <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-elim-after.png" alt="full-graph-elim-after.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-6">
<h3 id="sec-2-6">fence position</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

&#9654; <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut.png" alt="full-graph-cut.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-7">
<h3 id="sec-2-7">fence position</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

&#9654; <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut-highlight.png" alt="full-graph-cut-highlight.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-8">
<h3 id="sec-2-8">fence position</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

&#9654; <span class="org-variable-name">K</span>  = Cut(G1, O2)

  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut-highlight-2.png" alt="full-graph-cut-highlight-2.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-9">
<h3 id="sec-2-9">fence placement</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

&#9654; <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-refine.png" alt="full-graph-refine.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-10">
<h3 id="sec-2-10">fence placement</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-variable-name">K</span>  = Cut(G1, O2)

&#9654; <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-refine-apply.png" alt="full-graph-refine-apply.png" />
</p>
</div>

<p>
 </div>
</p>
</section>
</section>
<section>
<section id="slide-sec-2-11">
<h3 id="sec-2-11">main theorem</h3>
<p>
\(\mathsf{Insert}(G, A, O), A \vDash O\)
</p>

<aside class="notes">
<p>
Intuitively, if we have at least one "big hammer fence" for A
that will work to keep any instructions we might pair from
trading places in execution then Insert will enforce the orders
we have defined by getting a fence between them on all possible
execution paths
</p>

<p>
We briefly discuss the subtlety introduced by fence selection in the paper
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3">
<h2 id="sec-3">Results/Parry</h2>
<div class="outline-text-2" id="text-3">
</div></section>
</section>
<section>
<section id="slide-sec-3-1">
<h3 id="sec-3-1">benchmark: classic algorithms</h3>
<ul>
<li>from Algave et al '14</li>
<li>x86 and ARMv7</li>
<li>4 lock free algorithms</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-3-2">
<h3 id="sec-3-2">benchmark: STM algorithms</h3>
<ul>
<li>TL2/TL2 Eager</li>
<li>Rochester ByteEager (TLRW)</li>
<li>x86 and ARMv7</li>
<li>compared with hand placed fences (baseline)
<ul>
<li>fence placement and count</li>
<li>STAMP performance benchmarks</li>

</ul></li>

</ul>
<aside class="notes">
<ul class="org-ul">
<li>TL2/TL2 Eager
<ul class="org-ul">
<li>included with STAMP Benchmarks
</li>
</ul>
</li>
<li>RSTM ByteEager
<ul class="org-ul">
<li>part of Rochester STM Algorithm Suite
</li>
</ul>
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-3">
<h3 id="sec-3-3">tl2 - ARMv7</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><b><code>TxStore</code></b></td>
<td class="left">baseline</td>
<td class="left">ours</td>
</tr>

<tr>
<td class="left">1886 \(\xrightarrow{ld,ld}\) 1923</td>
<td class="left"><span class="hlght"> 1920: <code>dmb</code> </span></td>
<td class="left"><span class="hlght"> 1886: <code>dmb</code> </span></td>
</tr>
</tbody>
</table>


<aside class="notes">
<p>
TxStore: we placed our fence "further up" the control flow graph,
this is dues to the way the multicut algorithm handles a sequence
of similarly weighted edges, choosing the first
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-4">
<h3 id="sec-3-4">tl2 eager - ARMv7</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><b><code>TxCommit</code></b></td>
<td class="left">baseline</td>
<td class="left">ours</td>
</tr>

<tr>
<td class="left">760 \(\xrightarrow{st,st}\) 1413</td>
<td class="left"><span class="hlght"> 1669: <code>dmb st</code> </span></td>
<td class="left"><span class="hlght">  — </span></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Not that due to the ifdefs we saw in the example earlier we are
able to eliminate the stst fence at line 1669 on arm
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-5">
<h3 id="sec-3-5">rstm - ARMv7</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><b><code>read_rw</code></b></td>
<td class="left">baseline</td>
<td class="left">ours</td>
</tr>

<tr>
<td class="left">163 \(\xrightarrow{st,ld}\) 165</td>
<td class="left"><span class="hlght"> 163: <code>ldrex/strex</code> </span></td>
<td class="left"><span class="hlght"> 163: <code>dmb st</code> </span></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
in the <code>read_rw</code> method of the RSTM ByteEager algorithm they use a
compare and swap to enforce a store/store order
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3-6">
<h3 id="sec-3-6">tl2 performance</h3>

<div class="figure">
<p><img src="./assets/images/stamp-arm-tl2.png" alt="stamp-arm-tl2.png" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-sec-3-7">
<h3 id="sec-3-7">rstm performance</h3>

<div class="figure">
<p><img src="./assets/images/stamp-arm-rstm.png" alt="stamp-arm-rstm.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-sec-4">
<h2 id="sec-4">algorithms = code + orders</h2>
<ul>
<li>Describe the algorithm behavior</li>
<li>Let the compiler enforce the orders</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-5">
<h2 id="sec-5">Thanks!</h2>
</section>
</section>
</div>
</div>

<script src="assets/reveal/lib/js/head.min.js"></script>
<script src="assets/reveal/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: false,
progress: true,
history: true,
center: true,
slideNumber: true,
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'assets/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'assets/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'assets/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'assets/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: 'assets/reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'assets/reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
]
});
</script>
</body>
</html>
