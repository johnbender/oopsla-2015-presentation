<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Declarative Fence Insertion</title>

<link rel="stylesheet" href="assets/reveal/css/reveal.css"/>
<link rel="stylesheet" href="assets/reveal/css/theme/white.css" id="theme"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'assets/reveal/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" type="text/css" href="assets/style.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1>Declarative Fence Insertion</h1>
<h2></h2>
<h2><a href="mailto:johnbender@cs.ucla.edu">johnbender@cs.ucla.edu</a></h2>
<h2></h2>
</section>
</section>
</section>
<section>
<section id="slide-sec-0-1">
<h3 id="sec-0-1">mutex</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
    flag[i] = <span class="org-constant">true</span>;
    <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
Here we have some example code from the art of multiproc
programming
</p>

<p>
It's lock that's intended to guarantee mutual exclusion for two
threads
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-2">
<h3 id="sec-0-2">mutual exclusion proof</h3>
<p>
The Art of Multiprocessor Programming, 2.3.1
</p>

<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
&#9654;   flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<aside class="notes">
<p>
These two lines are critical:
</p>

<ul class="org-ul">
<li>the first records an intent to enter a critical section guarded by the lock
at the flag index corresponding to the thread id
</li>
<li>the second checks the other thread's flag and spins until it's false (unlocked)
</li>
</ul>

<p>
The proof of mutual exclusion in the book requires that these two
lines execute in program order
</p>

<p>
More specifically, their interactions with memory must take effect
in program order
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-3">
<h3 id="sec-0-3">Bad execution</h3>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Thread 0</th>
<th scope="col" class="left">Thread 1</th>
<th scope="col" class="left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>flag[0] = true</code></td>
<td class="left">&#xa0;</td>
<td class="left">buffered</td>
</tr>

<tr>
<td class="left"><code>flag[1] : false</code></td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[1] = true</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>flag[0] : false</code></td>
<td class="left">bad!</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">enter cs</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">enter cs</td>
<td class="left">&#xa0;</td>
<td class="left">bad!</td>
</tr>
</tbody>
</table>

<p>
Possible under Java, x86, ARM, and Power
</p>

<aside class="notes">
<p>
For example if the write to flag<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> in thread 0 is buffered, thread
1 may read false in this execution allowing both threads to acquire
the lock and enter the critical section
</p>

<p>
Note that this is possible under extremely common memory models
like Java, x86, ARM, and Power
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div>
</aside>

</section>
</section>
<section>
<section id="slide-sec-0-4">
<h3 id="sec-0-4">ensuring correctness</h3>
<ol>
<li>sequential consistency</li>
<li><code>volatile</code> modifier</li>
<li>memory fences</li>

</ol>

<blockquote nil>
<p>
Pragma 2.3.1. In practice, the Boolean flag variables &#x2026; must all
be declared <code>volatile</code> to work properly.
</p>
</blockquote>

<aside class="notes">
<p>
How do we prevent these kinds of issues?
</p>

<p>
sequential consistency is expensive and not required by the proof
</p>

<p>
volatile affects all writes to the modified variable, but we only
care about on write in particular
</p>

<p>
in C/C++ memory fences relate many instructions before and after,
sacrificing information about the actual required behavior
</p>

<p>
All of these are implementation details of a higher level concept
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-0-5">
<h3 id="sec-0-5">execution order</h3>
<blockquote nil>
<p>
The requirement that two instructions be seen to execute in the
order they appear in the program.
</p>
</blockquote>

</section>
</section>
<section>
<section id="slide-sec-0-6">
<h3 id="sec-0-6">algorithms: code <b>and</b> orders</h3>
<div class="org-src-container">

<pre  class="src src-java"><span class="org-keyword">class</span> <span class="org-type">LockOne</span> <span class="org-keyword">implements</span> <span class="org-type">Lock</span> {
  <span class="org-keyword">private</span> <span class="org-type">boolean</span>[] <span class="org-variable-name">flag</span> = <span class="org-keyword">new</span> <span class="org-type">boolean</span>[2];

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">lock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
&#9654;   flag[i] = <span class="org-constant">true</span>;
&#9654;   <span class="org-keyword">while</span> (flag[j]) {}
  }

  <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">unlock</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
    flag[i] = <span class="org-constant">false</span>;
  }
}
</pre>
</div>

<p>
\({st(\mathtt{flag[i]}) \rightarrow ld(\mathtt{flag[j]})}\)
</p>

</section>
</section>
<section>
<section id="slide-sec-1">
<h2 id="sec-1">Problem Subtleties</h2>
<aside class="notes">
<p>
We have an idea of what we think algorithms should look like,
what's standing in our way?
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-1-1">
<h3 id="sec-1-1">cross platform</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
  flag[i] = <span class="org-constant">true</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">for x86</span>
  <span class="org-keyword">__asm__</span> (<span class="org-string">"mfence"</span>);
  <span class="org-comment-delimiter">// </span><span class="org-comment">for arm</span>
  <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb"</span>);

  <span class="org-keyword">while</span> (flag[j]) {} <span class="org-comment-delimiter">// </span><span class="org-comment">wait</span>
}
</pre>
</div>

<aside class="notes">
<p>
assuming we're programming at the level of C/C++ we need to use an
architecture appropriate fence instruction to ensure the two orders
defined in the proof
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-2">
<h3 id="sec-1-2">fence selection</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;
  flag[i] = <span class="org-constant">true</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">either will work in this case</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">`dmb st` is "faster"</span>
  <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb"</span>);
  <span class="org-keyword">__asm__</span> (<span class="org-string">"dmb st"</span>);

  <span class="org-keyword">while</span> (flag[j]) {} <span class="org-comment-delimiter">// </span><span class="org-comment">wait</span>
}
</pre>
</div>

<aside class="notes">
<p>
different paired instructions may require different fences,
optimizing for performance
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-3">
<h3 id="sec-1-3">existing fence(-likes)</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">lock</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = ThreadID.get();
  <span class="org-type">int</span> <span class="org-variable-name">j</span> = i-1;

  <span class="org-comment-delimiter">// </span><span class="org-comment">x86 `cmpxchg` has fence-like semantics</span>
  CAS(flag[i], <span class="org-constant">false</span>, <span class="org-constant">true</span>);

  <span class="org-keyword">while</span> (flag[j]) {} <span class="org-comment-delimiter">// </span><span class="org-comment">wait</span>
}
</pre>
</div>

<aside class="notes">
<p>
there are other instructions like `cmpxhg` which have fence like
semantics that we should account for (by avoiding adding more fences).
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-4">
<h3 id="sec-1-4">TL2 STM Algorithm</h3>
<div class="org-src-container">

<pre  class="src src-c++">...

<span class="org-preprocessor"># if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
<span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
  WriteBackForward(wr);
}
<span class="org-preprocessor"># endif</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
MEMBARSTST();

<span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
DropLocks(Self, wv);

<span class="org-comment-delimiter">// </span><span class="org-comment">ensure later loads from above writes</span>
MEMBARSTLD();

...
</pre>
</div>
<aside class="notes">
<p>
commit procedure for the tl2 software transactional memory algorithm
writebackforward is where the actual writes to memory take place
droplocks releases locks for the memory addresses for other commit calls to write
macros provided for implementors to define arch appropriate fences
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-5">
<h3 id="sec-1-5">loops</h3>
<div class="org-src-container">

<pre  class="src src-c">...

<span class="org-preprocessor"># if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
<span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
  WriteBackForward(wr);

  <span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
  MEMBARSTST();
}
<span class="org-preprocessor"># endif</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
DropLocks(Self, wv);

<span class="org-comment-delimiter">// </span><span class="org-comment">ensure later loads from above writes</span>
MEMBARSTLD();

...
</pre>
</div>

<aside class="notes">
<p>
bad to put a fence right after writebackforward (loop)
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-6">
<h3 id="sec-1-6">code transformations</h3>
<div class="org-src-container">

<pre  class="src src-c">...

<span class="org-preprocessor"># if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
<span class="org-comment-delimiter">// </span><span class="org-comment">for (wr = logs; wr != end; wr++) {</span>
<span class="org-comment-delimiter">//   </span><span class="org-comment">// write the deferred stores</span>
<span class="org-comment-delimiter">//   </span><span class="org-comment">WriteBackForward(wr);</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">}</span>
<span class="org-preprocessor"># endif</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
MEMBARSTST();

<span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
DropLocks(Self, wv);

<span class="org-comment-delimiter">// </span><span class="org-comment">ensure later loads from above writes</span>
MEMBARSTLD();

...
</pre>
</div>

<aside class="notes">
<p>
bad to use a fence if <code>TL2_EAGER</code> is defined (will remove writebackforward)
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-1-7">
<h3 id="sec-1-7">unnecessary</h3>
<div class="org-src-container">

<pre  class="src src-c">...

<span class="org-preprocessor"># if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> TL2_EAGER
<span class="org-keyword">for</span> (wr = logs; wr != end; wr++) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">write the deferred stores</span>
  WriteBackForward(wr);
}
<span class="org-preprocessor"># endif</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">make stores visible before unlock</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">MEMBARSTST();</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">release locks and increment version</span>
DropLocks(Self, wv);

<span class="org-comment-delimiter">// </span><span class="org-comment">ensure later loads from above writes</span>
MEMBARSTLD();

...
</pre>
</div>

<aside class="notes">
<p>
bad to use a fence for <code>MEMBARSTST</code> on x86
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-2">
<h2 id="sec-2">Algorithm</h2>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
  <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph.png" alt="full-graph.png" />
</p>
</div>

<p>
 </div>
</p>

<aside class="notes">
<ol class="org-ol">
<li>We eliminate orders which are enforced on the target
architecture, e.g. a store -&gt; store order on x86 is enforced
by the architecture. <b>optimization</b>
</li>

<li>We find a multicut for the remaining orders and the control flow graph G
</li>

<li>We use the cut to insert fences on the cut set edges
</li>
</ol>

</aside>

</section>
</section>
<section>
<section id="slide-sec-2-1">
<h3 id="sec-2-1">order elimination</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
&#9654; <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
  <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-elim.png" alt="full-graph-elim.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-2">
<h3 id="sec-2-2">order elimination</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
&#9654; <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
  <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-elim-after.png" alt="full-graph-elim-after.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-3">
<h3 id="sec-2-3">multi-cut</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
&#9654; <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut.png" alt="full-graph-cut.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-4">
<h3 id="sec-2-4">multi-cut</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
&#9654; <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
  <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-cut-highlight.png" alt="full-graph-cut-highlight.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-5">
<h3 id="sec-2-5">place fences</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
  <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
&#9654; <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-refine.png" alt="full-graph-refine.png" />
</p>
</div>

<p>
 </div>
</p>

</section>
</section>
<section>
<section id="slide-sec-2-6">
<h3 id="sec-2-6">place fences</h3>
<div class="org-src-container">

<pre  class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Insert : CFG x Arch x Orders -&gt; CFG</span>
<span class="org-keyword">def</span> <span class="org-function-name">Insert</span>(G1, A, O1):

  <span class="org-comment-delimiter"># </span><span class="org-comment">Elim : CFG x Arch x Orders -&gt; Orders</span>
  <span class="org-variable-name">O2</span> = O1 \ Elim(G, A, O1)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Cut : CFG x Orders -&gt; CutSet</span>
  <span class="org-variable-name">K</span>  = Cut(G, O2)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Refine : CFG x CutSet -&gt; CFG</span>
&#9654; <span class="org-variable-name">G2</span> = Refine(G1, K)

  <span class="org-keyword">return</span> G2
end
</pre>
</div>

<p>
 <div class="algo-graph">
</p>

<div class="figure">
<p><img src="assets/images/full-graph-refine-apply.png" alt="full-graph-refine-apply.png" />
</p>
</div>

<p>
 </div>
</p>
</section>
</section>
<section>
<section id="slide-sec-2-7">
<h3 id="sec-2-7">main theorem</h3>
<p>
\(\mathsf{Insert}(G, A, O), A \vDash O\)
</p>

<aside class="notes">
<p>
Intuitively, if we have at least one "big hammer fence" for A
that will work to keep any instructions we might pair from
trading places in execution then Insert will enforce the orders
we have defined by getting a fence between them on all possible
execution paths
</p>

<p>
We briefly discuss the subtlety introduced by fence selection in the paper
</p>

</aside>

</section>
</section>
<section>
<section id="slide-sec-3">
<h2 id="sec-3">Implementation</h2>

<div class="figure">
<p><img src="./assets/images/impl-diagram.png" alt="impl-diagram.png" />
</p>
</div>

<aside class="notes">
<ul class="org-ul">
<li>Our tool Parry takes an architecture specification, source and
orders and provides source with fences to enforce those orders
</li>

<li>Parry is built on top of LLVM's IR and wraps both Clang and
LLVM's opt tool.
</li>

<li>Edge elimination shrinks the control flow graph to speed up
Elimination
</li>

<li>Order elimination corresponds with Elim
</li>

<li>Assigning cycle capacities ensures that we avoid placing fences
in loops unless otherwise completely necessary
</li>
</ul>

</aside>

</section>
</section>
<section>
<section id="slide-sec-4">
<h2 id="sec-4">Results</h2>
<p>
TODO include tables?
</p>
</section>
</section>
<section>
<section id="slide-sec-4-1">
<h3 id="sec-4-1">summary</h3>
<ul>
<li>x86 arm</li>
<li>two transaction memory algorithms</li>
<li>four classic lock free algorithms</li>
<li>match or better hand placed/selected fences</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-4-2">
<h3 id="sec-4-2">performance</h3>
<ul>
<li>exponential time order elimination algorithm</li>
<li>linear time order elimination algorithm</li>

</ul>

<div class="figure">
<p><img src="./assets/images/linear-perf.png" alt="linear-perf.png" />
</p>
</div>

<ul>
<li>notes

<p>
most of the time in processing is spent in generating the
modified control flow graph in Python, everything else appeals to
optimized C/C++ depedencies
</p></li>

</ul>

</section>
</section>
<section>
<section id="slide-sec-4-3">
<h3 id="sec-4-3">classic</h3>
<ul>
<li>matched all hand placed fences</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-4-4">
<h3 id="sec-4-4">tl2</h3>
<ul>
<li>one fence saved!</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-4-5">
<h3 id="sec-4-5">tl2 eager</h3>
<ul>
<li>one fence saved!</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-4-6">
<h3 id="sec-4-6">rstm</h3>
<ul>
<li>notes about cmpxchg</li>

</ul>

</section>
</section>
<section>
<section id="slide-sec-5">
<h2 id="sec-5">Related</h2>
<div class="outline-text-2" id="text-5">
</div></section>
</section>
<section>
<section id="slide-sec-5-1">
<h3 id="sec-5-1">semantics</h3>
<ul>
<li>weak memory calculus from CMU</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-5-2">
<h3 id="sec-5-2">recovering sequential consistency</h3>
<ul>
<li>Don't Sit on the Fence [Alglave]</li>
<li>Hiding relaxed memory consistency with a compiler [Lee]</li>

<li>notes

<p>
all whole program
</p></li>

</ul>

</section>
</section>
<section>
<section id="slide-sec-5-3">
<h3 id="sec-5-3">enforcing arbitrary properties</h3>
<ul>
<li>Automatic inference of memory fences [Kuperstein]</li>
<li>Synthesis of memory fences via refinement propagation [Meshman]</li>

<li>notes

<p>
all whole program
</p></li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-6">
<h2 id="sec-6">Thanks!</h2>
</section>
</section>
</div>
</div>

<script src="assets/reveal/lib/js/head.min.js"></script>
<script src="assets/reveal/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: false,
progress: true,
history: true,
center: true,
slideNumber: true,
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'assets/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'assets/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'assets/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'assets/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: 'assets/reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'assets/reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
]
});
</script>
</body>
</html>
