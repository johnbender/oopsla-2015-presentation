* declarative orders
** loose definition
   #+BEGIN_QUOTE
   The requirement that two instructions be seen to execute in program order.
   #+END_QUOTE

** the art of multiprocessor programming, 2.3.1 ~LockOne~ class
   #+INCLUDE: "code/LockOne.java" src java

   - notes

     Two threads only, waits for other thread's flag to be false.
     Enters critical section when it is

** mutual exclusion proof requires two orders
   #+BEGIN_EXAMPLE
   writeA(flag[A] = true)  -> readA(flag[B] == false) -> CSA (2.3.1)
   writeB(flag[B] = true)  -> readB(flag[A] == false) -> CSB (2.3.2)
   #+END_EXAMPLE

   - notes

     2.3.1 and 2.3.2 are assumed, which may not hold under weak memory
     models in particular java's or if this were an unmanaged language
     x86, arm, power.

     for example on x86, the write to ~flag[A]~ or ~flag[B]~ may be
     delayed in reaching the other thread allowing it to read ~false~

** traditionally solved with fences or volatile class members

   #+BEGIN_QUOTE
   Pragma 2.3.1. In practice, the Boolean flag variables ... must all
   be declared volatile to work properly.
   #+END_QUOTE

   - notes

     fences and volatile variables are the implementation details of
     more a precise tool: declarative orders.


** algorithms code *and* orders

   #+BEGIN_EXAMPLE
   writeA(flag[A] = true) -> readA(flag[B] == false)
   writeB(flag[B] = true) -> readB(flag[A] == false)
   #+END_EXAMPLE

   - notes

   In our work we propose that these orders be specified as part of
   the algorithm and that the responsibility for enforcing them be
   delegated to the compiler.

* Concurrent Failure
** A Delicate Activity

   Optimizing further by dividing the work amongst two actors, the
   second actor checks for jelly before finishing the sandwich:

   | chef 1              | chef 2       |
   |---------------------+--------------|
   | get bread           |              |
   | apply peanut butter |              |
   | apply jelly         |              |
   |                     | check jelly  |
   |                     | close halves |

   Applying the same optimization to this division of labor from
   before causes catastrophe:

   | chef 1                  | chef 2       |
   |-------------------------+--------------|
   | get bread               |              |
   | apply jelly             |              |
   |                         | check jelly  |
   |                         | close halves |
   | BAD apply peanut butter |              |
   |                         |              |

* Dekker's Mutex
** explain the algorithm/code sample
** show an example execution assuming SC

   | P0        | P1          |
   |-----------+-------------|
   | ~flag0=1~ |             |
   | ~flag1:0~ |             |
   |           | ~flag1=1~   |
   |           | ~flag0:1~   |
   |           | return      |
   | enter     |             |

** example assuming store buffering

   | P0        | P1          |
   |-----------+-------------|
   | ~flag0=1~ |             |
   | ~flag1:0~ |             |
   |           | ~flag1=1~   |
   |           | ! ~flag0:0~ |
   |           | enter       |
   | enter     |             |

** example assuming out of order execution

   | P0          | P1        |
   |-------------+-----------|
   | ~flag1:0~   |           |
   |             | ~flag1=1~ |
   |             | ~flag0:0~ |
   | ! ~flag0=1~ |           |
   |             | enter     |
   | enter       |           |

** code sample with fences to show how to prevent this behavior

* summarize the problem
** what we want:
   - SC semantics
   - x-platform
   - performance
** what we don't want:
   - actual SC (slow)
   - user intervention
** example of SC semantics that doesn't require it (critical section of dekker)
** example of cross platform different fences/memory models)
** example of cross platform fence selection
** example of existing fences like compaire and swap

* more complex example with TL2 TxCommit
* our approach
** describe order specification
** examples with orders as graph lines or similar
   - Dekker with orders
   - TL2 STM with orders
** value proposition
   - declarative
   - exact
   - often included
   - effective
* experimental results
** classic
** STM algorithms
* related work
** semantics
   - weak memory calculus from CMU
** recovering sequential consistency
   - Don't Sit on the Fence [Alglave]
   - Hiding relaxed memory consistency with a compiler [Lee]
   - all, whole program
** enforcing arbitrary properties
   - Automatic inference of memory fences [Kuperstein]
   - Synthesis of memory fences via refinement propagation [Meshman]
   - all, whole program
